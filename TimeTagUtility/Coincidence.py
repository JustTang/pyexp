import clr
import os
from pyexp import FileHelper
import numpy as np

clr.AddReference('TimeTagAnalyze')
import TimeTagAnalyze as ttA

import pyexp.TimeTagUtility.NumpyNetTypeConverter as nnConv

class PresetData(object):

    def GetDefaultResolution(device):
        '''
        device:{'UQDevice_h', 'UQDevice_l'}
        '''
        resolutionDict = {'UQDevice_h':78.125e-12,
                          'UQDevice_l':156.25e-12}
        res = resolutionDict.get(device)
        if(res != None):
            return res
        else:
            raise ValueError("No such device.")



class CoincidenceAnalyzer(object):

    def __init__(self, channelNum, deviceResolution):
        self.maxChannelNum = channelNum
        self.ttResolution = deviceResolution

    def GetCoPattern(self, rawCoPattern):
        coPattern = np.zeros(len(rawCoPattern), np.dtype('int32'))
        for i,pattern in enumerate(rawCoPattern):
            if pattern:
                coPattern[i] = ttA.CoincHelper.CoPattern2Int(
                nnConv.asNetArray(np.array(pattern, np.dtype('uint8'))))
            else:   #handle empty list
                coPattern[i] = 0
        return coPattern

    def GetCoincidence(self, channel, timetag, delay, coPattern, coWindow):
        coCount = ttA.Coincidence.GetCoincidence(
                    nnConv.asNetArray(channel),nnConv.asNetArray(timetag),nnConv.asNetArray(delay),
                    nnConv.asNetArray(coPattern), coWindow, self.maxChannelNum)
        return nnConv.asNumpyArray(coCount)

    def GetCoincidenceFixCoCount(self, channel, timetag, delay, coPattern, coWindow,
                                 countLast, coCountPosList, nSingle):
        coCount = ttA.Coincidence.GetCoincidenceFixCoCount(
                    nnConv.asNetArray(channel), nnConv.asNetArray(timetag),
                    nnConv.asNetArray(delay), nnConv.asNetArray(coPattern), coWindow, 
                    nnConv.asNetArray(countLast), nnConv.asNetArray(coCountPosList), nSingle, 
                    self.maxChannelNum)
        return nnConv.asNumpyArray(coCount)

    def DelayScan(self, channel, timetag, coWindow, searchRange, searchStep, coChannel):
        '''Get the unknown delay between two channel in [coChannel];
        the delay applied to the first one in [coChannel] is 0
            
        Arguments:
            channel {np.array['uint8']} -- channel number array generated by CoDevice
            timetag {np.array['int64']} -- timetag array generated by CoDevice
            coWindow {int} -- coincidence window
            searchRange {list} -- delay search range(list with only 2 numbers)
            searchStep {int} -- step length of delay search
            coChannel {list} -- the 2 channels to coincidence
        
        Returns:
            delaySearch {np.array[int]} -- a series of delay settings applied to the second one in [coChannel]
            coCounts {np.array[int]} -- coincidence counts under different delay settings

        (PS: CoDevice resolution -- the unit of params except [channel] and [coChannel])
        '''

        delaySearch, coCounts = ttA.Coincidence.DelayScan(
                [], nnConv.asNetArray(channel), nnConv.asNetArray(timetag), coWindow,
                nnConv.asNetArray(np.array(searchRange, np.dtype('int64'))), searchStep, 
                coChannel[0], coChannel[-1], self.maxChannelNum)

        return nnConv.asNumpyArray(delaySearch), nnConv.asNumpyArray(coCounts)

    def SaveSampleTimetagData(self, channel, timetag, fileFolder):
        np.save(FileHelper.GetFilePath(fileFolder,'channelNpArray'), channel)
        np.save(FileHelper.GetFilePath(fileFolder,'timetagNpArray'), timetag)

    def LoadSampleTimetagData(self, fileFolder):
        chArray = np.load("./%s/channelNpArray.npy"%fileFolder)
        tagArray = np.load("./%s/timetagNpArray.npy"%fileFolder)
        return chArray, tagArray

    def ns2tagUnit(self, ns:"int or list"):
        '''return [int] or [np.array]'''
        if(isinstance(ns,list)):
            return np.array([round(val*1e-9/self.ttResolution) for val in ns], np.dtype('int64'))
        else:
            return round(ns*1e-9/self.ttResolution)

    def tagUnit2ns(self, tag:"int or np.array"):
        return tag*self.ttResolution/1e-9

    